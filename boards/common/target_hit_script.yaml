# ==============================================================================
# TARGET HIT SCRIPTS - general target hit behavior 
# ==============================================================================
script:
  # Main Target Hit Script - Standalone version
  - id: target_hit_script
    mode: single  # Prevent overlapping hits
    then:
      - logger.log: "Target hit detected - processing..."
      # Disable IR during hit processing
      - globals.set:
          id: ir_enabled
          value: 'false'
      
      # Disable auto-save during hit processing to prevent overwriting saved effect
      - globals.set:
          id: hit_processing
          value: 'true'
      
      # Log hit information for standalone mode
      - lambda: |-
          ESP_LOGI("target_hit", "Hit detected - Player: %d, Points: ${default_points}", id(ir_command));
      
      - delay: 100ms
      
      # Save current effect index
      - lambda: |-
          std::string current_effect = id(led_strip).get_effect_name();
          int effect_index = 0;
          if (current_effect == "Rainbow Effect") effect_index = 1;
          else if (current_effect == "Color Wipe Effect") effect_index = 2;
          else if (current_effect == "Scanner Effect") effect_index = 3;
          else if (current_effect == "Twinkle Effect") effect_index = 4;
          id(saved_effect_index) = effect_index;
          ESP_LOGI("target_hit", "Saved effect index: %d", effect_index);
      
      # Apply hit effect
      - if:
          condition:
            lambda: 'return id(hit_effect_select).state == "Solid Color";'
          then:
            - light.turn_on:
                id: led_strip
                effect: "None"
            - if:
                condition:
                  lambda: 'return id(led_strip_color_preset) != nullptr;'
                then:
                  - select.set:
                      id: led_strip_color_preset
                      option: !lambda 'return id(led_strip_color_preset).state;'
          else:
            - light.turn_on:
                id: led_strip
                effect: !lambda 'return id(hit_effect_select).state;'
      
      # Activate outputs with error checking
      - lambda: |-
          if (id(relay_1).state) {
            ESP_LOGW("target_hit", "Relay already active!");
          }
      - switch.turn_on: relay_1
      
      # Hold relay for configured time while hit effect displays
      - delay: !lambda 'return id(relay_timer);'
      
      # Deactivate outputs
      - switch.turn_off: relay_1
      
      # Continue displaying hit effect until total hit_display_time is reached
      - delay: !lambda |-
          int remaining_display = ${hit_display_time} - id(relay_timer);
          return std::max(0, remaining_display);
      
      # LEDs off during cooldown
      - light.turn_off: led_strip 
      
      # Final cooldown period
      - delay: !lambda 'return id(cooldown_timer);'

      # Restore original effect
      - lambda: |-
          std::string effect_name = "Scanner Effect";  // Default fallback
          switch (id(saved_effect_index)) {
            case 1: effect_name = "Rainbow Effect"; break;
            case 2: effect_name = "Color Wipe Effect"; break;
            case 3: effect_name = "Scanner Effect"; break;
            case 4: effect_name = "Twinkle Effect"; break;
            default: 
              ESP_LOGW("target_hit", "Unknown effect index: %d, using default", id(saved_effect_index));
              break;
          }
          auto call = id(led_strip).turn_on();
          call.set_effect(effect_name);
          call.perform();
          ESP_LOGI("target_hit", "Restored effect: %s", effect_name.c_str());
      
      
      # Re-enable auto-save and IR
      - globals.set:
          id: hit_processing
          value: 'false'
      - globals.set:
          id: ir_enabled
          value: 'true'
      - logger.log: "Target hit processing complete"


 