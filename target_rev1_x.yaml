# ==============================================================================
# SUBSTITUTIONS - Configuration Variables
# ==============================================================================
substitutions:
  # Hardware Configuration
  hit_display_time: "3000"       # Time to display hit effect
  default_relay_time: "3000"     # Relay activation time after hit in milliseconds
  default_cooldown_time: "1000"  # Time target is inactive after hit in milliseconds
  default_points: "10"           # Points awarded for hitting this target

  # Target Internal GPIO Pins
  led_gpio: GPIO5        # Main target LED strip
  ir_gpio: GPIO19        # IR receiver
  relay_gpio: GPIO23     # Relay output

  # Right Side Connector Pins
  tx_gpio: GPIO01        # UART TX
  rx_gpio: GPIO03        # UART RX
  io22_gpio: GPIO22      # General I/O
  io21_gpio: GPIO21      # General I/O
  io25_gpio: GPIO25      # General I/O
  io32_gpio: GPIO32      # General I/O
  
  # Left Side Connector Pins
  io33_gpio: GPIO33      # General I/O
  io34_gpio: GPIO34      # ADC input (input only)
  io35_gpio: GPIO35      # ADC input (input only)
  io4_gpio: GPIO4        # PWM 2
  io0_gpio: GPIO0        # PWM 1
  io2_gpio: GPIO2        # PWM 0

  # Project Information
  project_name: "CodeMakesItGo.Target"
  project_version: "1.0.0"

# ==============================================================================
# EXTERNAL PACKAGES
# ==============================================================================
packages:
  color_controls: !include color_controls.yaml
    
  # Change this manually when changing target_type:
  # - For standalone: uncomment the next line
  #config_file: !include target_standalone_config.yaml
  # - For networked: uncomment the next line
  config_file: !include target_home_assistant_config.yaml

# ==============================================================================
# CORE CONFIGURATION
# ==============================================================================
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.7.4  
  name_add_mac_suffix: false
  platformio_options:
    board_build.flash_mode: dio
  project:
    name: ${project_name}
    version: ${project_version}
  on_boot:
    priority: 300
    then:
      # Initialize timer controls with saved values
      - number.set:
          id: relay_timer_control
          value: !lambda 'return id(relay_timer);'
      - number.set:
          id: target_cooldown_control
          value: !lambda 'return id(cooldown_timer);'
      # Wait for components to initialize
      - delay: 500ms
      # Log startup completion
      - logger.log: "Target system initialized successfully"

esp32:
  board: wemos_d1_mini32
  framework:
    type: arduino
    version: recommended
  flash_size: 4MB

# ==============================================================================
# NETWORK & DEBUGGING
# ==============================================================================
logger:
  level: DEBUG
  logs:
    adc: INFO  # Reduce ADC-related log spam
  
web_server: # Target web page
  port: 80
  include_internal: true
  css_include: "custom.css"
  js_include: "custom.js"
  version: 2

# Allow Over-The-Air updates
ota: 
  - platform: esphome
    password: ""
# ==============================================================================
# SENSORS
# ==============================================================================
sensor:
  # System uptime monitoring
  - platform: uptime
    name: "Uptime Sensor"
    update_interval: 60s  # Reduce frequency for less spam
    
  # Analog voltage measurement on GPIO34 
  - platform: adc
    pin: 
      number: ${io34_gpio}
    name: "GPIO34 Voltage"
    update_interval: 5s
    accuracy_decimals: 2
    unit_of_measurement: "V"
    attenuation: 12db  # Explicit attenuation for 0-3.3V range
    raw: false
    filters:
      - multiply: 3.3
      - offset: -0.25
      - lambda: 'return std::max(0.0f, x);'
    on_value_range:
      - below: 0.5
        then:
          - logger.log: "WARNING: Low voltage detected on GPIO34"
          
  # Analog voltage measurement on GPIO35 
  - platform: adc
    pin: 
      number: ${io35_gpio}
    name: "GPIO35 Voltage"
    update_interval: 5s
    accuracy_decimals: 2
    unit_of_measurement: "V"
    attenuation: 12db  # Explicit attenuation for 0-3.3V range
    raw: false
    filters:
      - multiply: 3.3
      - offset: -0.25
      - lambda: 'return std::max(0.0f, x);'
    on_value_range:
      - below: 0.5
        then:
          - logger.log: "WARNING: Low voltage detected on GPIO35"

# ==============================================================================
# BINARY SENSORS - Digital Inputs
# ==============================================================================
binary_sensor:
  
  # GPIO21 Digital Input
  - platform: gpio
    pin:
      number: ${io21_gpio}
      mode: INPUT_PULLUP
      inverted: true
    name: "GPIO21 Digital State"
    device_class: "motion"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      - logger.log: "GPIO21 state is HIGH"
    on_release:
      - logger.log: "GPIO21 state is LOW"

  # GPIO25 Digital Input
  - platform: gpio
    pin:
      number: ${io25_gpio}
      mode: INPUT_PULLUP
      inverted: true
    name: "GPIO25 Digital State"
    device_class: "motion"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      - logger.log: "GPIO25 state is HIGH"
    on_release:
      - logger.log: "GPIO25 state is LOW"

  # GPIO32 Digital Input
  - platform: gpio
    pin:
      number: ${io32_gpio}
      mode: INPUT_PULLUP
      inverted: true
    name: "GPIO32 Digital State"
    device_class: "motion"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      - logger.log: "GPIO32 state is HIGH"
    on_release:
      - logger.log: "GPIO32 state is LOW"

  # GPIO33 Digital Input
  - platform: gpio
    pin:
      number: ${io33_gpio}
      mode: INPUT_PULLUP
      inverted: true
    name: "GPIO33 Digital State"
    device_class: "motion"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      - logger.log: "GPIO33 state is HIGH"
    on_release:
      - logger.log: "GPIO33 state is LOW"
# ==============================================================================
# INFRARED RECEIVER
# ==============================================================================
remote_receiver:
  pin:
    number: ${ir_gpio}
    inverted: true      # Keep this for most IR receiver modules (TSOP, etc.)
    mode:
      input: true
      pullup: true
  tolerance: 25%
  filter: 100us
  idle: 40ms
  on_nec:
    then:
      - if:
          condition:
            - lambda: 'return id(ir_enabled);'
          then:
            # Process IR command - keep debug logging if needed for troubleshooting
            - lambda: |-
                ESP_LOGI("ir_debug", "Address: 0x%04X, Command: 0x%02X", x.address, x.command & 0xFF);
                id(ir_command) = x.command & 0xFF;  // Store full 16-bit command
            - script.execute: target_hit_script
            - logger.log: "IR Command Completed"    
          else:
            - logger.log: "IR Command Ignored (disabled)"

# ==============================================================================
# SCRIPTS - Target Logic
# ==============================================================================
script:
  # Main Target Hit Script - integrated hit display logic
  - id: target_hit_script
    mode: single  # Prevent overlapping hits
    then:
      - logger.log: "Target hit detected - processing..."
      # Disable IR during hit processing
      - globals.set:
          id: ir_enabled
          value: 'false'
      
      # Send Home Assistant event only if API is connected (networked mode)
      - if:
          condition:
            api.connected:
          then:
            - homeassistant.event:
                event: esphome.target-hit
                data:  
                  address: ${ip}
                  player: !lambda 'return id(ir_command);'
                  points: ${default_points}
          else:
            - logger.log: "Standalone mode - no HA event sent"
      
      - delay: 100ms
      
      # Save current effect index
      - lambda: |-
          std::string current_effect = id(led_strip).get_effect_name();
          int effect_index = 0;
          if (current_effect == "Rainbow Effect") effect_index = 1;
          else if (current_effect == "Color Wipe Effect") effect_index = 2;
          else if (current_effect == "Scanner Effect") effect_index = 3;
          else if (current_effect == "Twinkle Effect") effect_index = 4;
          id(saved_effect_index) = effect_index;
          ESP_LOGI("target_hit", "Saved effect index: %d", effect_index);
      
      # Apply hit effect
      - if:
          condition:
            lambda: 'return id(hit_effect_select).state == "Solid Color";'
          then:
            - light.turn_on:
                id: led_strip
                effect: "None"
            - if:
                condition:
                  lambda: 'return id(led_strip_color_preset) != nullptr;'
                then:
                  - select.set:
                      id: led_strip_color_preset
                      option: !lambda 'return id(led_strip_color_preset).state;'
          else:
            - light.turn_on:
                id: led_strip
                effect: !lambda 'return id(hit_effect_select).state;'
      
      # Activate outputs with error checking
      - lambda: |-
          if (id(relay_1).state) {
            ESP_LOGW("target_hit", "Relay already active!");
          }
      - switch.turn_on: relay_1
      
      # Hold relay for configured time while hit effect displays
      - delay: !lambda 'return id(relay_timer);'
      
      # Deactivate outputs
      - switch.turn_off: relay_1
      
      # Continue displaying hit effect until total hit_display_time is reached
      - delay: !lambda |-
          int remaining_display = ${hit_display_time} - id(relay_timer);
          return std::max(0, remaining_display);
      
      # Restore original effect
      - lambda: |-
          std::string effect_name = "Scanner Effect";  // Default fallback
          switch (id(saved_effect_index)) {
            case 1: effect_name = "Rainbow Effect"; break;
            case 2: effect_name = "Color Wipe Effect"; break;
            case 3: effect_name = "Scanner Effect"; break;
            case 4: effect_name = "Twinkle Effect"; break;
            default: 
              ESP_LOGW("target_hit", "Unknown effect index: %d, using default", id(saved_effect_index));
              break;
          }
          auto call = id(led_strip).turn_on();
          call.set_effect(effect_name);
          call.perform();
          ESP_LOGI("target_hit", "Restored effect: %s", effect_name.c_str());
      
      # Final cooldown period
      - delay: !lambda 'return id(cooldown_timer);'
      
      # Re-enable IR
      - globals.set:
          id: ir_enabled
          value: 'true'
      - logger.log: "Target hit processing complete"

# ==============================================================================
# LIGHTING - LED Strips
# ==============================================================================
light:
  # Main Target LED Strip (6 LEDs) - Use SPI method to free up RMT channels
  - platform: esp32_rmt_led_strip
    chipset: WS2812  # Changed back to WS2812 for main strip
    rmt_symbols: 64
    rgb_order: GRB
    pin: 
      number: ${led_gpio}
      ignore_strapping_warning: true
    num_leds: 6
    name: "Target LEDs"
    id: led_strip
    default_transition_length: 500ms
    color_correct: [100%, 100%, 100%]
    restore_mode: RESTORE_AND_ON
    effects:
      - addressable_rainbow:
          name: Rainbow Effect
          speed: 10
          width: 50
      - addressable_color_wipe:
          name: Color Wipe Effect
          colors:
            - red: 100%
              green: 0%
              blue: 0%
              num_leds: 1
            - red: 0%
              green: 100%
              blue: 0%
              num_leds: 1
            - red: 0%
              green: 0%
              blue: 100%
              num_leds: 1
      - addressable_scan:
          name: Scanner Effect
      - addressable_twinkle:
          name: Twinkle Effect

  # Placeholder LED Strip 2 (not connected in rev1 hardware)
  - platform: esp32_rmt_led_strip
    chipset: WS2812
    rmt_symbols: 64
    rgb_order: RGB
    pin: ${io22_gpio}  # Using available GPIO22
    num_leds: 1
    name: "LED Strip 2"
    id: led_strip2
    internal: true  # Hide from UI since it's not used
    restore_mode: RESTORE_DEFAULT_OFF

# ==============================================================================
# SWITCHES - Digital Outputs
# ==============================================================================
switch:
  # Main relay output
  - platform: gpio
    pin:
      number: ${relay_gpio}
    name: "Relay"
    id: relay_1

  # Test button for manual hit simulation
  - platform: template
    name: "Test Button"
    id: test_button
    turn_on_action:
      - logger.log: "Test button pressed!"
      - script.execute: target_hit_script
      - logger.log: "Test complete!"
      - switch.turn_off:
          id: test_button


# ==============================================================================
# USER CONTROLS - Numbers and Selects
# ==============================================================================
number:
  # Relay activation duration control
  - platform: template
    name: "Relay Timer"
    id: relay_timer_control
    min_value: 100
    max_value: 60000
    step: 100
    restore_value: true  # Should restore
    optimistic: true
    initial_value: ${default_relay_time}
    icon: "mdi:timer-outline"
    unit_of_measurement: "ms"
    set_action:
      - lambda: |-
          int value = static_cast<int>(x); 
          id(relay_timer) = value;
          ESP_LOGI("config", "Relay timer set to: %d ms", value);
          
  # Target cooldown period control
  - platform: template
    name: "Cooldown Timer"
    id: target_cooldown_control
    min_value: 0
    max_value: 60000
    step: 100
    restore_value: true  # Should restore
    optimistic: true
    initial_value: ${default_cooldown_time}  # Use new default
    icon: "mdi:timer-sand"
    unit_of_measurement: "ms"
    set_action:
      - lambda: |-
          int value = static_cast<int>(x); 
          id(cooldown_timer) = value;
          ESP_LOGI("config", "Cooldown timer set to: %d ms", value);

select:
  # Hit effect selection
  - platform: template
    name: "Target LEDs Hit Effect"
    id: hit_effect_select
    options:
      - "Rainbow Effect"
      - "Color Wipe Effect"
      - "Scanner Effect"
      - "Twinkle Effect"
      - "Solid Color"
    initial_option: "Color Wipe Effect"
    restore_value: true
    optimistic: true

# ==============================================================================
# GLOBAL VARIABLES
# ==============================================================================
globals:
  # IR receiver enable/disable state
  - id: ir_enabled
    type: bool
    restore_value: no
    initial_value: 'true'
    
  # Last received IR command
  - id: ir_command
    type: int
    restore_value: no
    initial_value: '0'

  # Saved LED effect as index (more reliable than string)
  - id: saved_effect_index
    type: int
    restore_value: yes
    initial_value: '3'  # Scanner Effect = 3
    
  # Relay activation duration (milliseconds)
  - id: relay_timer
    type: int
    restore_value: true
    initial_value: ${default_relay_time}
    
  # Target cooldown period (milliseconds)
  - id: cooldown_timer
    type: int
    restore_value: true
    initial_value: ${default_cooldown_time}  # Use new default